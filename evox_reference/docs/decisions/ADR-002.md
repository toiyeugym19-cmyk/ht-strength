# ADR-002: Hierarchical Memory Architecture

## Status
Accepted

## Context
Context windows are finite. You cannot dump an agent's entire history into a prompt. A 200k token context window sounds large until you realize:
- A month of work logs could be 500k+ tokens
- Code context for a large feature can be 50k tokens
- Leaving room for actual work requires careful memory management

## Decision
**Memory must be hierarchical** â€” structured in layers by recency and relevance.

### Memory Layers
1. **Working Memory (WORKING.md)**: What I'm doing right now
   - Current task and status
   - Recent decisions and blockers
   - Refreshed every session

2. **Daily Notes**: What happened today
   - Standup summaries
   - Completed tasks
   - Key decisions made
   - Rotates daily

3. **Long-term Memory (SOUL.md)**: Who I am and what I've learned
   - Agent identity and role
   - Learned preferences
   - Domain expertise
   - Updated rarely, high signal

### Schema Design
```typescript
agentMemory: defineTable({
  agentId: v.string(),
  type: v.union(v.literal("working"), v.literal("daily"), v.literal("longterm")),
  content: v.string(),
  updatedAt: v.number(),
})
```

## Consequences
### Positive
- Fits within context limits
- Most relevant context loaded first
- Clear separation of concerns
- Efficient boot sequence

### Negative
- Requires summarization logic
- Risk of losing important details in compression
- More complex than flat storage

## References
- Truth 2: Context windows are finite
- AGT-107: SOUL.md per agent
- AGT-109: WORKING.md memory system
